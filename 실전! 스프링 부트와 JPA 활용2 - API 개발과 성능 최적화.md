## API 스펙을 위한 별도의 DTO를 만들어야한다.

entity의 스펙이 변하면 API 스펙도 변하기 때문에 **API 스펙만을 위한 DTO**을 만들어야 한다.

- entity를 파라미터로 받으면 안된다.
- 바인딩 시 어떤 값들이 명확히 넘어오는지 알 수 있다. → 유지보수 쉬워짐

이에 추가된 주의사항

- 엔티티를 직접 노출 시 양방향 연관관계가 걸린 곳 중 한 곳은 반드시 `@JsonIgnore` 를 해줘야한다.
- 지연로딩을 피하기 위해 즉시 로딩을 설정하면 안된다. 즉시 로딩 떄문에 연관관계가 필요 없는 경우에도 데이터를 항상 조회해서 성능 문제가 발생할 수 있다. 즉시 로딩으로 설정하면 성능 튜닝이 매우 어려워 짐 항상 지연 로딩을 기본으로 하고, **성능 최적화가 필요한 경우 패치 조인을 사용해라**
- DTO을 반환 이 오시 연관 관계에 있는 entity 모두 DTO로 바꿔야한다.
    - ex) Order을 DTO로 반환할 때 연관관계인 OrderItem도 DTO로 바꿔서 반환해야한다.

## to one 관계는 fetch Join 잡고, 페이징의 여부, 컬렉션 Join 여부에 따라 최적화를 다르게해라

- ToOne 관계는 모두 페치조인한다. 왜냐면 ToOne관계는 row수를 증가시키지 않아 페이징 쿼리에 영향 x
- 컬렉션은 항상 지연로딩으로 조회
- 지연 로딩 성능 최적화를 위해 `hibernate.default_batch_fetch_size`, `@BatchSzie`를 적용한다.
    - 이 옵션을 사용하면 컬렉션이나, 프록시 객체를 한꺼번에 설정한 size만큼 in쿼리로 조회한다.

### 지연 로딩 성능 최적화의 장점

- 쿼리 호출 수가 `1+N` -> `1+1` 최적화 된다.
- 조인보다 DB 데이터 전송량이 최적화 된다. (Order와 OrderItem을 조인하면 Order가 OrderItem 만큼 중복해서 조회된다. 이 방법은 각각 조회하므로 중복데이터 가없음
- 페치 조인과 비교해서 쿼리 호출 수가 약간 증가하지만 DB 데이터 전송량이 감소한다.
- 컬렉션 페치 조인은 페이징이 불가하지만 이 방법은 페이징이 가능하다.
- 결론
    - ToOne관계는 페치 조인해도 페이징에 영향을 주지 않는다. 따라서 ToOne 관계는 페치 조인으로 쿼리 수를 줄이고 해결하고, 나머지는 `hibernate.default_batch_fetch_size`로 최적화 하자.

## API Response는 유연성을 위해 껍데기 class가 필요하다.

회원 목록 조회에서 단순 List 데이터 타입으로 response 한다면, 확장성이 떨어진다.

```java
[
	{"name" : "kim"},
  {"name" : "park"},
...
]
```

위 응답값은 List 타입이며, 더이상 확장이 불가능하다. 그래서 아래 응답값과 같이 껍데이 class를 씌어준다.