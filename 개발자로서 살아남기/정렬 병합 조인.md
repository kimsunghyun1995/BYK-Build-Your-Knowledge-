# 정렬 병합 조인

조회의 범위가 많을 때 주로 사용하는 조인 방법론이며 양쪽 테이블을 각각 Access 하여 그 결과를 정렬하고 그 정렬한 결과를 차례로 스캔해 나가면서 연결고리의 조건으로 Merge를 하는 방식이다. 

### 사용 조건

**1.** 연결 고리에 인덱스가 전혀 없는 경우

**2.** 대용량의 자료를 조인할때 유리한 경우

**3.** 조인 조건으로 <, >, <=, >=와 같은 범위 비교 연산자가 사용된 경우

**4.** 인덱스 사용에 따른 랜덤 액세스의 오버헤드가 많은 경우

### 동작방식

아래와 같은 SQL이 있다고 가정해보자

```java
select /**USER_MERGE(A B) */ A.Color, B.SIZE,...
from TABLE_A A,TABLE_B B
where a.joinkey_a = b.joinkey_b -- join key에 대한 인덱스가 테이블 둘 모두 다 없음
and a.color = 'RED' --인덱스 있음
and b.size = 'MED'; --인덱스 없음
```

위와 같은 쿼리에 color칼럼에만 인덱스가 있다고 가정하였을 때 SORT MERGE JOIN로 이 쿼리가 동작된다면 아래와 같은 프로세스로 동작하게 된다.

![Untitled](%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20%E1%84%87%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%B8%20%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%B5%E1%86%AB%20b499a566c2804debaf920a04962c740d/Untitled.png)

먼저 왼쪽과 오른쪽에 있는 TABLE_A와 TABLE_B를 동시에 ACCESS 한다.

여기서 COLOR에 인덱스가 걸려있기에 TABLE_A는 인덱스 스캔을 할 것이고 TABLE_B는 테이블 풀스캔을 한다. 이렇게 조회된 데이터들은 TABLE_A에서 읽은 데이터는 JOINKEY_A를 기준으로, TABLE_B에서 읽은 데이터는 JOINKEY_B를 통해 별도의 공간에서 SORT 작업을 거치게 된다.

 두 개의 정렬 작업이 모두 완료되었다면 정렬한 결과를 차례로 Scan 해 나가면서 연결고리의 조건으로 Merge 하여 리턴하게 된다.

위에서 설명한 SORT MERGE JOIN의 동작 방식의 내용을 간단하게 다시 정리하자면 아래의 3단계로 이루어진다고 생각하면 된다.

**1.** 각 테이블에 대해 동시에 독립적으로 데이터를 먼저 읽어 들인다.

**2.** 읽혀진 각 테이블의 데이터를 조인을 위한 연결고리에 대하여 정렬을 수행한다.

**3.** 정렬이 모두 끝난 후에 조인 작업이 수행한다.

## **SORT MERGE JOIN의 성능개선**

### 정렬속도 향상

SORT MERGE JOIN은 조인할 테이블의 데이터를 정렬시키는데, 만약 조인 컬럼이 정렬이 되어 있다면 좀 더 빨라질 것이다.

### ****SORT_AREA_SIZE 최적화****

SORT MERGE JOIN은 두 테이블 간의 비교가 이루어지기 전에 수행하는 정렬 작업을 위해 별도의 정렬 공간이 필요하며 이 공간은 SORT_AREA_SIZE 크기만큼 메모리를 할당받아 사용하게 되고, 메모리가 부족하다면 Temporary Table Space를 이용하여 정렬을 수행하게 된다. 이때 Temporary Table Space를 사용하면 딜레이가 생기므로 SORT_AREA_SIZE를 적당한 크기로 설정해두는 것이 속도 향상에 도움이 된다.