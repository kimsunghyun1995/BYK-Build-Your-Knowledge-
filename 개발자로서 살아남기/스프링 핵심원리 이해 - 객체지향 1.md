컴공에 입문하거나, 혹은 프로그래밍을 한다면 **객체 지향 설계**에 대해 안들어 볼 수가 없다.  
또, 현재 대한민국은 자바공화국이라 불릴만큼 자바를 많이 사용하고, 스프링 프레임워크를 같이 사용하고 있다.

## 스프링의 핵심

-   스프링은 **자바** 언어 기반의 프레임 워크
-   자바는 **객체 지향** 언어
-   스프링은 객체 지향 언어가 가장 강력한 특징을 살려내는 프레임워크
-   스프링은 **좋은 객체 지향** 애플리케이션을 개발 할 수 있게 도와주는 프레임워크

\-> 그렇다면 **좋은 객체 지향**이란 무엇일까?

## 좋은 객체 지향

-   객체 지향 프로그래밍은 **유연하고 변경이 용이(다형성)** 하게 만들기 때문에 대규모 SW개발에 많이 사용된다.

## SRP 단일 책임 원칙

-   **한 클래스는 하나의 책임**만 가져야 한다.
-   중요한 기준은 변경이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것

## OCP 개방-폐쇄 원칙

-   소프트 웨어 요소는 확장에는 열려 있으나, 변경에는 닫혀 있어야 한다.
-   **다형성**을 활용

## OCP 개방-폐쇄 원칙 문제점

-   `MemberService` 클라이언트가 구현 클래스를 직접 선택
    -   `MemberRepository m = new MemoryMemberRepository(); // 기존 코드`
    -   `MemberRepository m = new JdbcMemberRepository(); // 변경 코드`
-   **구현 객체를 변경하려면 클라이언트 코드 변경 필요**
-   **다형성을 사용했지만 OCP 원칙을 지킬 수 없음**
-   객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요(스프링 컨테이너)

## DIP 의존관계 역전 원칙

-   프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다." 라는 원칙을 따르는 방법 중 하나.
-   쉽게 이야기 하면 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
-   앞서 이야기한 **역할에 의존하게 해야 한다는 것과 같다.**
-   OCP에서 설명한 `MemberService`는 인터페이스에 의존하지만 구현 클래스도 동시에 의존 (아래 예시)
    -   `MemberRepository m = new MemoryMemberRepository();`
    -   `memberService` 클라이언트가 구현 클래스를 직접 선택
    -   DIP 위반!

## 핵심

-   객체 지향의 핵심은 다형성이지만, 다형성 만으로는 OCP와 DIP를 지킬 수 없다. -> 뭔가 더 필요(스프링)

## 스프링과 좋은 객체지향

-   스프링은 다음 기술로 다형성 + OCP, DIP를 가능하게 지원한다.
    -   DI(Dependency Injection): 의존관계, 의존성 주입
    -   DI 컨테이너 제공
-   클라이언트 코드를 변경 없이 기능 확장

## 결론

좋은 객체지향을 위해서는 **다형성** 이라는 개념이 가장 중요한데, 모순적으로 **자바에서 다형성은 OCP와 DIP 원칙을 구조적으로 지키지 못하게** 되어있다.  
이 때 등장한 것이 스프링 프레임워크이고, 스프링의 기술로 **다형성과 OCP, DIP**을 지킬 수 있게 된 것이다.